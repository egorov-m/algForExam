# Алгоритмы: Материалы для экзамена.

## Билет 1: Пузырьковая сортировка (Bubble Sort)

### Описание
Простейший алгоритм сортировки, который многократно меняет местами соседние элементы, если они расположены в неправильном порядке. Проход по списку повторяется до тех пор, пока список не будет отсортирован.

**Сложность:** *O(n^2)*, в лучшем случае (коллекция уже отсортирована) *O(n)*, алгоритм не подходит для большинства наборов данных, поскольку его временная сложность в среднем и худшем случае довольно высока.

**Вспомогательное пространство:** *O(1)*.

Дополнительно: https://www.geeksforgeeks.org/bubble-sort/

### [Реализация (C# пример)](./algForExam/BubbleSortExtensions.cs)
```cs
public static IList<T> BubbleSort<T>(this IList<T> collection) where T : IComparable
{
    for (var i = 0; i < collection.Count; i++)
    {
        for (var j = i + 1; j < collection.Count; j++)
        {
            if (collection[i].CompareTo(collection[j]) > 0) // Сортировка по возрастанию
            {
                (collection[j], collection[i]) = (collection[i], collection[j]);
            }
        }
    }

    return collection;
}
```

## Билет 2: Сортировка вставками (Insertion Sort)

### Описание
Простой алгоритм сортировки, который работает аналогично тому, как происходит сортировка игральных карт в руках. Массив мысленно разделён на отсортированную и неотсортированную части. Значения из несортированной части выбираются и помещаются в правильную позицию в отсортированной части.

Этот алгоритм является одним из самых простых в реализации, эффективен для небольших наборов данных, носит адоптивный характер: подходит для частично отсортированных наборов.

**Сложность:**
- <u>Лучший случай:</u> *O(n)*, возникает в случае, если массив уже отсортирован;
- <u>Средний случай:</u> *O(n^2)*, элементы перемешаны в порядке так, что порядок не является должным образов возрастающим или убывающим;
- <u>Худший случай:</u> *O(n^2)*, возникает в случае, когда массив уже отсортирован в обратном порядке;

**Вспомогательное пространство:** *O(1)*.

Дополнительно: https://www.geeksforgeeks.org/insertion-sort/

### [Реализация (C# пример)](./algForExam/InsertionSortExtensions.cs)
```cs
public static IList<T> InsertionSort<T>(this IList<T> collection) where T : IComparable
{
    for (var i = 1; i < collection.Count; i++)
    {
        var item = collection[i];
        var j = i - 1;

        while (j >= 0 && collection[j].CompareTo(item) > 0) // Сортировка по возрастанию
        {
            collection[j + 1] = collection[j];
            j--;
        }

        collection[j + 1] = item;
    }

    return collection;
}
```

## Билет 3: Сортировка выбором (Selection Sort)

### Описание
Алгоритм сортирует массив, многократно находя минимальный элемент (с учётом возрастания) из несортированной части и помещая его в начало. Алгоритм поддерживает два под массива в заданном массиве: под массив, который уже отсортирован, оставшийся под массив — неотсортированный.

По-умолчанию реализация алгоритма не [стабильна*](#стабильный-алгоритм). Однако этого можно достичь путём замены операции смены элементов местами на операцию толкания элементов вперёд.

#### Стабильный алгоритм:
Тот алгоритм, который не меняет порядок элементов с одинаковыми ключами относительно друг друга.

**Сложность:** *O(n^2)* — во всех случаях, так-как есть два вложенных цикла: один цикл для выбора элемента массива один за другим *O(n)*, другой цикл для сравнения этого элемента с любым другим *O(n)*.

**Вспомогательное пространство:** *O(1)*.

Дополнительно: https://www.geeksforgeeks.org/selection-sort, https://www.geeksforgeeks.org/stable-selection-sort/

### [Реализация (C# пример)](./algForExam/SelectionSortExtensions.cs)
```cs
public static IList<T> SelectionSort<T>(this IList<T> collection) where T : IComparable
{
    for (var i = 0; i < collection.Count - 1; i++)
    {
        var index = i;
        for (var j = i + 1; j < collection.Count; j++)
        {
            if (collection[index].CompareTo(collection[j]) > 0) // Сортировка по возрастанию
            {
                index = j;
            }
        }

        (collection[index], collection[i]) = (collection[i], collection[index]);
    }

    return collection;
}
```

## Билет 4: “Шейкерная” сортировка (Сортировка перемешиванием, Двунаправленная сортировка, Cocktail Sort)

### Описание
Разновидность [пузырьковой сортировки](#билет-1-пузырьковая-сортировка-bubble-sort). Алгоритм пузырьковой сортировки всегда обходит элементы слева и перемещает самый большой элемент в правильное положение на первой итерации, второй по величине — на второй и так далее. Коктейльная сортировка попеременно проходит через заданный массив в обоих направлениях. Коктейльная сортировка не требует ненужных итераций, что делает ее эффективной для больших массивов.

**Каждая итерация алгоритма разбивается на два этапа:**
1. Первый этап перебирает массив слева направо, как и при пузырьковой сортировке. Во время цикла сравниваются соседние элементы, и если значение слева больше значения справа, значения меняются местами. В конце первой итерации наибольшее число будет находиться в конце массива.
2. Второй этап проходит по массиву в обратном направлении — начиная с элемента, непосредственно предшествующего последнему отсортированному элементу, и возвращаясь к началу массива. Здесь также сравниваются соседние элементы и при необходимости меняются местами.

**Сравнение с пузырьковой сортировкой:** временная сложность такая же, но Коктельная сортировка работает лучше, чем пузырьковая, обычно мене чем в два раза быстрее.

**Сложность:** *O(n^2)*, в лучшем случае (коллекция уже отсортирована) *O(n)*.

**Вспомогательное пространство:** *O(1)*.

Дополнительно: https://www.geeksforgeeks.org/cocktail-sort/

### [Реализация (C# пример)](./algForExam/CocktailSortExtensions.cs)
```cs
public static IList<T> CocktailSort<T>(this IList<T> collection) where T : IComparable
{
    for (var i = 0; i < collection.Count; i++)
    {
        var needSort = false;
        for (var j = i; j < collection.Count - 1 - i; j++)
        {
            if (collection[j].CompareTo(collection[j + 1]) > 0) // Сортировка по возрастанию
            {
                (collection[j], collection[j + 1]) = (collection[j + 1], collection[j]);
                needSort = true;
            }
        }

        for (var j = collection.Count - 2 - i; j > i; j--)
        {
            if (collection[j - 1].CompareTo(collection[j]) > 0) // Сортировка по возрастанию
            {
                (collection[j], collection[j - 1]) = (collection[j - 1], collection[j]);
                needSort = true;
            }
        }

        if (!needSort) return collection;
    }

    return collection;
}
```

## Билет 5: Сортировка Шелла (Shell Sort)

### Описание
Это обобщённая версия [алгоритма сортировки вставками](#билет-2-сортировка-вставками-insertion-sort). Сначала сортируются элементы, находящиеся далеко друг от друга, и последовательно уменьшается интервал между сортируемыми элементами, таким образом выполняется меньше обменов.

Интервал между сортируемыми элементами сокращается в зависимости от используемой последовательности. Вот несколько оптимальных последовательностей:
- Оригинальная последовательность Shell: *N/2*, *N/4*, *...*, *1*;
- Последовательность Кнута: *1*, *4*, *13*, ..., *(3^k - 1) / 2*;
- Последовательность Седжвика: *1*, *8*, *23*, *77*, *281*, *1073*, *4193*, *16577...4j+1+ 3\*2j+ 1*;
- Приращение Хиббарда: *1*, *3*, *7*, *15*, *31*, *63*, *127*, *255*m *511*, *...*;
- Последовательность Папернова и Стасевича: *1*, *3*, *5*, *9*, *17*, *33*, *65*, *...*;
- Последовательность Пратт: *1, 2, 3, 4, 6, 9, 8, 12, 18, 27, 16, 24, 36, 54, 81, ...*;

**Сложность:** 
- <u>Лучший случай:</u> *O(n\*log(n))*, возникает в случае, если массив уже отсортирован, общее количество сравнений для каждого интервала равно размеру массива;
- <u>Средний случай:</u> *O(n\*log(n))*, около *O(n^1.25)*;
- <u>Худший случай:</u> *O(n^2)*, согласно теореме Пунена — сложность равна что-то вроде: *O(n \* log(n))^2 / (log(log(n))^2)* или *O(n \* log(n))^2 / log(log(n))* или *O(n \* (log(n))^2)*

Сложность зависит от выбранной последовательности, для каждой конкретной отличается. Лучшая последовательность неизвестна.

**Вспомогательное пространство:** *O(1)*.

Дополнительно: https://www.geeksforgeeks.org/shellsort, https://www.programiz.com/dsa/shell-sort

### [Реализация (C# пример)](./algForExam/CocktailSortExtensions.cs)
```cs
public static IList<T> ShellSort<T>(this IList<T> collection) where T : IComparable
{
    var step = collection.Count / 2;
    while (step > 0)
    {
        step /= 2;
        for (var i = step; i < collection.Count; i++)
        {
            var j = i;
            while (j >= step && collection[j - step].CompareTo(collection[j]) > 0) // Сортировка по возрастанию
            {
                (collection[j], collection[j - step]) = (collection[j - step], collection[j]);
                j -= step;
            }
        }
    }

    return collection;
}
```
